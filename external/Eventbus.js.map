{"version":3,"file":"Eventbus.js","sources":["../../src/utils.js","../../src/Eventbus.js","../../src/EventbusProxy.js","../../src/EventbusSecure.js","../../src/index.js"],"sourcesContent":["/**\r\n * Regular expression used to split event strings.\r\n *\r\n * @type {RegExp}\r\n */\r\nexport const eventSplitter = /\\s+/;\r\n\r\n/**\r\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\r\n * callback` and jQuery-style event maps `{event: callback}`).\r\n *\r\n * @template T\r\n *\r\n * @param {Function}       iteratee - Event operation to invoke.\r\n *\r\n * @param {T}              events - Events object\r\n *\r\n * @param {string|object}  name - A single event name, compound event names, or a hash of event names.\r\n *\r\n * @param {Function}       callback - Event callback function\r\n *\r\n * @param {object}         opts - Optional parameters\r\n *\r\n * @returns {T} Events object or processed data.\r\n */\r\nexport function eventsAPI(iteratee, events, name, callback, opts)\r\n{\r\n   let i = 0, names;\r\n   if (name && typeof name === 'object')\r\n   {\r\n      // Handle event maps.\r\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\r\n      for (names = objectKeys(name); i < names.length; i++)\r\n      {\r\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\r\n      }\r\n   }\r\n   else if (name && eventSplitter.test(name))\r\n   {\r\n      // Handle space-separated event names by delegating them individually.\r\n      for (names = name.split(eventSplitter); i < names.length; i++)\r\n      {\r\n         events = iteratee(events, names[i], callback, opts);\r\n      }\r\n   }\r\n   else\r\n   {\r\n      // Finally, standard events.\r\n      events = iteratee(events, name, callback, opts);\r\n   }\r\n   return events;\r\n}\r\n\r\n/**\r\n * Returns a string to output for error messages including any eventbus name.\r\n *\r\n * @param {Eventbus|EventbusProxy|EventbusSecure} eventbus - The eventbus to format.\r\n *\r\n * @returns {string} A string representing the eventbus.\r\n */\r\nexport function getErrorName(eventbus)\r\n{\r\n   const name = eventbus.name;\r\n   return name !== '' ? `[${name}] ` : '';\r\n}\r\n\r\n/**\r\n * The reducing API that returns the options for an event. Any guarded event sets guard and the higher type is set.\r\n *\r\n * @param {object}   output - The output object.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {object} The output object.\r\n */\r\nexport function getOptions(output, name, callback, opts)\r\n{\r\n   const events = opts.events;\r\n\r\n   if (events)\r\n   {\r\n      const handlers = events[name];\r\n\r\n      if (Array.isArray(handlers))\r\n      {\r\n         for (const handler of handlers)\r\n         {\r\n            if (handler.options.guard)\r\n            {\r\n               output.guard = true;\r\n            }\r\n\r\n            if (handler.options.type > output.type)\r\n            {\r\n               output.type = handler.options.type;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return output;\r\n}\r\n\r\n/**\r\n * Provides  protected Object.keys functionality.\r\n *\r\n * @param {object}   object - Object to retrieve keys.\r\n *\r\n * @returns {string[]} Keys of object if any.\r\n */\r\nexport const objectKeys = (object) =>\r\n{\r\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\r\n};\r\n\r\n/**\r\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\r\n * it has been called the number of times specified by options.count.\r\n *\r\n * @param {Events}   map - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Function to invoke after event has been triggered once; `off()`\r\n *\r\n * @returns {Events} The Events object.\r\n */\r\nexport function beforeMap(map, name, callback, opts)\r\n{\r\n   const after = opts.after;\r\n   const count = opts.count + 1;\r\n\r\n   if (callback)\r\n   {\r\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\r\n      {\r\n         return callback.apply(this, arguments);\r\n      }, () => { after(name, beforeWrapper); });\r\n\r\n      beforeWrapper._callback = callback;\r\n   }\r\n   return map;\r\n}\r\n\r\n// Module Private ----------------------------------------------------------------------------------------------------\r\n\r\n/**\r\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\r\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\r\n * invocation.\r\n *\r\n * `after` is invoked after the count is reduced.\r\n *\r\n * @param {number}   count - The number of calls at which `before` is no longer invoked and then `after` is invoked.\r\n *\r\n * @param {Function} before - The function to restrict.\r\n *\r\n * @param {Function} after - The function to invoke after count number of calls.\r\n *\r\n * @returns {Function} Returns the new restricted function.\r\n */\r\nconst s_BEFORE = function(count, before, after)\r\n{\r\n   let result;\r\n\r\n   return function(...args)\r\n   {\r\n      if (--count > 0) { result = before.apply(this, args); }\r\n\r\n      if (count <= 1)\r\n      {\r\n         if (after) { after.apply(this, args); }\r\n         after = void 0;\r\n         before = void 0;\r\n      }\r\n\r\n      return result;\r\n   };\r\n};\r\n","import * as Utils from './utils.js';\r\n\r\n/**\r\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\r\n *\r\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\r\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\r\n * synchronous results.\r\n *\r\n * ---------------\r\n */\r\nexport default class Eventbus\r\n{\r\n   /**\r\n    * Stores the name of this eventbus.\r\n    *\r\n    * @type {string}\r\n    * @private\r\n    */\r\n   #name = '';\r\n\r\n   /**\r\n    * Stores the events map for associated events and callback / context data.\r\n    *\r\n    * @type {Events|{}}\r\n    * @private\r\n    */\r\n   #events;\r\n\r\n   /**\r\n    * Provides a constructor which optionally takes the eventbus name.\r\n    *\r\n    * @param {string}   name - Optional eventbus name.\r\n    */\r\n   constructor(name = '')\r\n   {\r\n      if (typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\r\n\r\n      this.#name = name;\r\n\r\n      /**\r\n       * Stores the Listening instances for this context.\r\n       *\r\n       * @type {object.<string, Listening>}\r\n       * @private\r\n       */\r\n      this._listeners = void 0;\r\n\r\n      /**\r\n       * A unique ID set when listened to.\r\n       *\r\n       * @type {string}\r\n       * @private\r\n       */\r\n      this._listenId = void 0;\r\n\r\n      /**\r\n       * Stores the Listening instances for other contexts.\r\n       *\r\n       * @type {object.<string, Listening>}\r\n       * @private\r\n       */\r\n      this._listeningTo = void 0;\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\r\n    * removed. When multiple events are passed in using the space separated syntax, the event\r\n    * will fire count times for every event you passed in, not once for a combination of all events.\r\n    *\r\n    * @param {number}            count - Number of times the function will fire before being removed.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @param {OnOptions}         [options] - Event registration options.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   before(count, name, callback, context = void 0, options = {})\r\n   {\r\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\r\n\r\n      const data = {};\r\n      if (this.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\r\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *entries(regex = void 0)\r\n   {\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               for (const event of this.#events[name])\r\n               {\r\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n               }\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            for (const event of this.#events[name])\r\n            {\r\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns the current event count.\r\n    *\r\n    * @returns {number} Returns the current event count.\r\n    */\r\n   get eventCount()\r\n   {\r\n      if (!this.#events) { return 0; }\r\n\r\n      return Object.keys(this.#events).length;\r\n   }\r\n\r\n   /**\r\n    * Returns the current callback count.\r\n    *\r\n    * @returns {number} The current callback count.\r\n    */\r\n   get callbackCount()\r\n   {\r\n      if (!this.#events) { return 0; }\r\n\r\n      let count = 0;\r\n\r\n      for (const name in this.#events) { count += this.#events[name].length; }\r\n\r\n      return count;\r\n   }\r\n\r\n   /**\r\n    * Returns the options of an event name.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {DataOutOptions} The event options.\r\n    */\r\n   getOptions(name)\r\n   {\r\n      const result = Utils.eventsAPI(Utils.getOptions, { guard: false, type: 0 }, name, void 0,\r\n       { events: this.#events });\r\n\r\n      let type = void 0;\r\n\r\n      switch(result.type)\r\n      {\r\n         case 1:\r\n            type = 'sync';\r\n            break;\r\n         case 2:\r\n            type = 'async';\r\n            break;\r\n      }\r\n\r\n      return { guard: result.guard, type };\r\n   }\r\n\r\n   /**\r\n    * Returns the trigger type of an event name.\r\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {string|undefined} The trigger type.\r\n    */\r\n   getType(name)\r\n   {\r\n      const result = Utils.eventsAPI(s_GET_TYPE, { type: 0 }, name, void 0, { events: this.#events });\r\n\r\n      switch(result.type)\r\n      {\r\n         case 1:\r\n            return 'sync';\r\n         case 2:\r\n            return 'async';\r\n         default:\r\n            return void 0;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns whether an event name is guarded.\r\n    *\r\n    * @param {string|object}  name - Event name(s) or event map to verify.\r\n    *\r\n    * @param {object}         [data] - Stores the output of which names are guarded.\r\n    *\r\n    * @returns {boolean} Whether the given event name is guarded.\r\n    */\r\n   isGuarded(name, data = {})\r\n   {\r\n      data.names = [];\r\n      data.guarded = false;\r\n\r\n      const result = Utils.eventsAPI(s_IS_GUARDED, data, name, void 0, { events: this.#events });\r\n\r\n      return result.guarded;\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keys(regex = void 0)\r\n   {\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield name;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield name;\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keysWithOptions(regex = void 0)\r\n   {\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield [name, this.getOptions(name)];\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield [name, this.getOptions(name)];\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns the current eventbus name.\r\n    *\r\n    * @returns {string} The current eventbus name.\r\n    */\r\n   get name()\r\n   {\r\n      return this.#name;\r\n   }\r\n\r\n   /**\r\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\r\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\r\n    * be removed all at once later on. The callback will always be called with object as context.\r\n    *\r\n    * @example\r\n    * view.listenTo(model, 'change', view.render);\r\n    *\r\n    * @param {object}            obj - Event context\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   listenTo(obj, name, callback)\r\n   {\r\n      if (!obj) { return this; }\r\n\r\n      const data = {};\r\n      if (s_TRY_CATCH_IS_GUARDED(obj, name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\r\n          + `- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\r\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\r\n      let listening = _listening = listeningTo[id];\r\n\r\n      // This object is not listening to any other events on `obj` yet.\r\n      // Setup the necessary references to track the listening callbacks.\r\n      if (!listening)\r\n      {\r\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\r\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\r\n      }\r\n\r\n      // Bind callbacks on obj.\r\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\r\n      _listening = void 0;\r\n\r\n      if (error) { throw error; }\r\n\r\n      // If the target obj is not an Eventbus, track events manually.\r\n      if (listening.interop) { listening.on(name, callback); }\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\r\n    *\r\n    * @param {number}            count - Number of times the function will fire before being removed.\r\n    *\r\n    * @param {object}            obj - Target event context.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   listenToBefore(count, obj, name, callback)\r\n   {\r\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\r\n         count,\r\n         after: this.stopListening.bind(this, obj)\r\n      });\r\n\r\n      return this.listenTo(obj, events);\r\n   }\r\n\r\n   /**\r\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\r\n    *\r\n    * @param {object}            obj - Target event context\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   listenToOnce(obj, name, callback)\r\n   {\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\r\n         count: 1,\r\n         after: this.stopListening.bind(this, obj)\r\n      });\r\n\r\n      return this.listenTo(obj, events);\r\n   }\r\n\r\n   /**\r\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\r\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\r\n    * will be removed. If no event is specified, callbacks for all events will be removed.\r\n    *\r\n    * Note that calling model.off(), for example, will indeed remove all events on the model — including events that\r\n    * Backbone uses for internal bookkeeping.\r\n    *\r\n    * @example\r\n    * // Removes just the `onChange` callback.\r\n    * object.off(\"change\", onChange);\r\n    *\r\n    * // Removes all \"change\" callbacks.\r\n    * object.off(\"change\");\r\n    *\r\n    * // Removes the `onChange` callback for all events.\r\n    * object.off(null, onChange);\r\n    *\r\n    * // Removes all callbacks for `context` for all events.\r\n    * object.off(null, null, context);\r\n    *\r\n    * // Removes all callbacks on `object`.\r\n    * object.off();\r\n    *\r\n    * @param {string|object}  [name] - Event name(s) or event map.\r\n    *\r\n    * @param {Function}       [callback] - Event callback function\r\n    *\r\n    * @param {object}         [context] - Event context\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   off(name, callback = void 0, context = void 0)\r\n   {\r\n      if (!this.#events) { return this; }\r\n\r\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, { context, listeners: this._listeners });\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\r\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\r\n    * \"change:selection\".\r\n    *\r\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\r\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\r\n    *\r\n    * @example\r\n    * The event string may also be a space-delimited list of several events...\r\n    * book.on(\"change:title change:author\", ...);\r\n    *\r\n    * @example\r\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\r\n    * the event as the first argument. For example, to proxy all events from one object to another:\r\n    * proxy.on(\"all\", function(eventName) {\r\n    *    object.trigger(eventName);\r\n    * });\r\n    *\r\n    * @example\r\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\r\n    * book.on({\r\n    *    \"change:author\": authorPane.update,\r\n    *    \"change:title change:subtitle\": titleView.update,\r\n    *    \"destroy\": bookView.remove\r\n    * });\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @param {OnOptions}         [options] - Event registration options.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   on(name, callback, context = void 0, options = {})\r\n   {\r\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\r\n      {\r\n         throw new TypeError(`'options' must be an object literal.`);\r\n      }\r\n\r\n      const data = {};\r\n      if (this.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\r\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, {\r\n         context,\r\n         ctx: this,\r\n         options,\r\n         listening: _listening\r\n      });\r\n\r\n      if (_listening)\r\n      {\r\n         const listeners = this._listeners || (this._listeners = {});\r\n         listeners[_listening.id] = _listening;\r\n\r\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\r\n         _listening.interop = false;\r\n      }\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\r\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\r\n    * will fire once for every event you passed in, not once for a combination of all events\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context.\r\n    *\r\n    * @param {OnOptions}         [options] - Event registration options.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   once(name, callback, context = void 0, options = {})\r\n   {\r\n      const data = {};\r\n      if (this.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\r\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\r\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\r\n    * on a specific object, or a specific event, or just a specific callback.\r\n    *\r\n    * @example\r\n    * view.stopListening();\r\n    *\r\n    * view.stopListening(model);\r\n    *\r\n    * @param {object}   obj - Event context\r\n    *\r\n    * @param {string}   [name] - Event name(s)\r\n    *\r\n    * @param {Function} [callback] - Event callback function\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   stopListening(obj, name = void 0, callback = void 0)\r\n   {\r\n      const listeningTo = this._listeningTo;\r\n      if (!listeningTo) { return this; }\r\n\r\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\r\n\r\n      for (let i = 0; i < ids.length; i++)\r\n      {\r\n         const listening = listeningTo[ids[i]];\r\n\r\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\r\n         if (!listening) { break; }\r\n\r\n         listening.obj.off(name, callback, this);\r\n\r\n         if (listening.interop) { listening.off(name, callback); }\r\n      }\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\r\n    * passed along to the event callbacks.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   trigger(name, ...args)\r\n   {\r\n      if (!this.#events) { return this; }\r\n\r\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this.#events, name, void 0, args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\r\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\r\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\r\n    */\r\n   async triggerAsync(name, ...args)\r\n   {\r\n      if (!this.#events) { return void 0; }\r\n\r\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this.#events, name, void 0, args);\r\n\r\n      // No event callbacks were triggered.\r\n      if (result === void 0) { return void 0; }\r\n\r\n      // A single Promise has been returned; just return it.\r\n      if (!Array.isArray(result)) { return result; }\r\n\r\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\r\n      // values from each Promise result removing any undefined values.\r\n      return Promise.all(result).then((results) =>\r\n      {\r\n         let allResults = [];\r\n\r\n         for (const pResult of results)\r\n         {\r\n            if (Array.isArray(pResult))\r\n            {\r\n               allResults = allResults.concat(pResult);\r\n            }\r\n            else if (pResult !== void 0)\r\n            {\r\n               allResults.push(pResult);\r\n            }\r\n         }\r\n\r\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\r\n      });\r\n   }\r\n\r\n   /**\r\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   triggerDefer(name, ...args)\r\n   {\r\n      setTimeout(() => { this.trigger(name, ...args); }, 0);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\r\n    * value or in an array and passes it back to the callee in a synchronous manner.\r\n    *\r\n    * @param {string}   name - Event name(s).\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {void|*|*[]} The results of the event invocation.\r\n    */\r\n   triggerSync(name, ...args)\r\n   {\r\n      if (!this.#events) { return void 0; }\r\n\r\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this.#events, name, void 0, args);\r\n   }\r\n}\r\n\r\n// Private / internal methods ---------------------------------------------------------------------------------------\r\n\r\n/**\r\n * Global listening object\r\n *\r\n * @type {Listening}\r\n */\r\nlet _listening;\r\n\r\n/**\r\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\r\n */\r\nclass Listening\r\n{\r\n   /**\r\n    * @type {Events|{}}\r\n    */\r\n   #events;\r\n\r\n   /**\r\n    * @type {string}\r\n    */\r\n   #id;\r\n\r\n   /**\r\n    * @type {object}\r\n    */\r\n   #listener;\r\n\r\n   /**\r\n    * @type {object}\r\n    */\r\n   #obj;\r\n\r\n   /**\r\n    * @type {boolean}\r\n    */\r\n   #interop;\r\n\r\n   /**\r\n    * Current listening count.\r\n    *\r\n    * @type {number}\r\n    */\r\n   #count = 0;\r\n\r\n   constructor(listener, obj)\r\n   {\r\n      this.#id = listener._listenId;\r\n      this.#listener = listener;\r\n      this.#obj = obj;\r\n      this.#interop = true;\r\n   }\r\n\r\n   // Cleans up memory bindings between the listener and the listenee.\r\n   cleanup()\r\n   {\r\n      delete this.#listener._listeningTo[this.#obj._listenId];\r\n      if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\r\n   }\r\n\r\n   get id() { return this.#id; }\r\n\r\n   get interop() { return this.#interop; }\r\n\r\n   get obj() { return this.#obj; }\r\n\r\n   incrementCount() { this.#count++; }\r\n\r\n   /**\r\n    * @see {@link Eventbus#on}\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @returns {Listening} This Listening instance.\r\n    */\r\n   on(name, callback, context = void 0)\r\n   {\r\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\r\n      {\r\n         context,\r\n         ctx: this,\r\n         options: {},\r\n         listening: this\r\n      });\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\r\n    * manual tracking to support events library interop.\r\n    *\r\n    * @param {string|object}     [name] - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   [callback] - Event callback function or context for event map.\r\n    */\r\n   off(name, callback)\r\n   {\r\n      let cleanup;\r\n\r\n      if (this.#interop)\r\n      {\r\n         this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, {\r\n            context: void 0,\r\n            listeners: void 0\r\n         });\r\n         cleanup = !this.#events;\r\n      }\r\n      else\r\n      {\r\n         this.#count--;\r\n         cleanup = this.#count === 0;\r\n      }\r\n\r\n      if (cleanup) { this.cleanup(); }\r\n   }\r\n\r\n   /**\r\n    * Sets interop.\r\n    *\r\n    * @param {boolean} value Value to set.\r\n    */\r\n   set interop(value)\r\n   {\r\n      /* c8 ignore next 1 */\r\n      if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\r\n      this.#interop = value\r\n   }\r\n}\r\n\r\n/**\r\n * The reducing API that returns the trigger type for an event. The higher type is set.\r\n *\r\n * @param {object}   output - The output object.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {object} The output object.\r\n */\r\nconst s_GET_TYPE = (output, name, callback, opts) =>\r\n{\r\n   const events = opts.events;\r\n\r\n   if (events)\r\n   {\r\n      const handlers = events[name];\r\n\r\n      if (Array.isArray(handlers))\r\n      {\r\n         for (const handler of handlers)\r\n         {\r\n            if (handler.options.type > output.type)\r\n            {\r\n               output.type = handler.options.type;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return output;\r\n}\r\n\r\n/**\r\n * The reducing API that tests if an event name is guarded. Any event data of a give event name can have the guarded\r\n * state set. If so the event name will be added to the output names array and `output.guarded` set to true.\r\n *\r\n * @param {object}   output - The output object.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {object} The output object.\r\n */\r\nconst s_IS_GUARDED = (output, name, callback, opts) =>\r\n{\r\n   const events = opts.events;\r\n\r\n   if (events)\r\n   {\r\n      const handlers = events[name];\r\n\r\n      if (Array.isArray(handlers))\r\n      {\r\n         for (const handler of handlers)\r\n         {\r\n            if (handler.options.guard)\r\n            {\r\n                output.names.push(name);\r\n                output.guarded = true;\r\n                return output;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return output;\r\n}\r\n\r\n/**\r\n * The reducing API that removes a callback from the `events` object.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {void|Events} Events object\r\n */\r\nconst s_OFF_API = (events, name, callback, opts) =>\r\n{\r\n   /* c8 ignore next 1 */\r\n   if (!events) { return; }\r\n\r\n   const context = opts.context, listeners = opts.listeners;\r\n   let i = 0, names;\r\n\r\n   // Delete all event listeners and \"drop\" events.\r\n   if (!name && !context && !callback)\r\n   {\r\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\r\n      {\r\n         listeners[names[i]].cleanup();\r\n      }\r\n      return;\r\n   }\r\n\r\n   names = name ? [name] : Utils.objectKeys(events);\r\n\r\n   for (; i < names.length; i++)\r\n   {\r\n      name = names[i];\r\n      const handlers = events[name];\r\n\r\n      // Bail out if there are no events stored.\r\n      if (!handlers) { break; }\r\n\r\n      // Find any remaining events.\r\n      const remaining = [];\r\n      for (let j = 0; j < handlers.length; j++)\r\n      {\r\n         const handler = handlers[j];\r\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\r\n          context && context !== handler.context)\r\n         {\r\n            remaining.push(handler);\r\n         }\r\n         else\r\n         {\r\n            const listening = handler.listening;\r\n            if (listening) { listening.off(name, callback); }\r\n         }\r\n      }\r\n\r\n      // Replace events if there are any remaining.  Otherwise, clean up.\r\n      if (remaining.length)\r\n      {\r\n         events[name] = remaining;\r\n      }\r\n      else\r\n      {\r\n         delete events[name];\r\n      }\r\n   }\r\n\r\n   return events;\r\n};\r\n\r\n/**\r\n * The reducing API that adds a callback to the `events` object.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {Events} Events object.\r\n */\r\nconst s_ON_API = (events, name, callback, opts) =>\r\n{\r\n   if (callback)\r\n   {\r\n      const handlers = events[name] || (events[name] = []);\r\n      const context = opts.context, ctx = opts.ctx, listening = opts.listening;\r\n\r\n      // Make a copy of options.\r\n      const options = JSON.parse(JSON.stringify(opts.options));\r\n\r\n      // Ensure that guard is set.\r\n      options.guard = typeof options.guard === 'boolean' ? options.guard : false;\r\n\r\n      // Make sure options.type is set.\r\n      switch(options.type)\r\n      {\r\n         case 'sync':\r\n            options.type = 1;\r\n            break;\r\n         case 'async':\r\n            options.type = 2;\r\n            break;\r\n         default:\r\n            options.type = 0;\r\n            break;\r\n      }\r\n\r\n      if (listening) { listening.incrementCount(); }\r\n\r\n      handlers.push({ callback, context, ctx: context || ctx, options, listening });\r\n   }\r\n   return events;\r\n};\r\n\r\n/**\r\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\r\n * callback` and jQuery-style event maps `{event: callback}`).\r\n *\r\n * @param {Function} iteratee - Trigger API\r\n *\r\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\r\n *\r\n * @param {Events|{}}   events - Array of stored event callback data.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {*} The results of the callback if any.\r\n */\r\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\r\n{\r\n   let results = void 0;\r\n   let i = 0, names;\r\n\r\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\r\n   // processed into a single array of results.\r\n   if (name && Utils.eventSplitter.test(name))\r\n   {\r\n      // Handle space-separated event names by delegating them individually.\r\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\r\n      {\r\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\r\n\r\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\r\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\r\n\r\n         // Handle an array result depending on existing results value.\r\n         if (Array.isArray(result))\r\n         {\r\n            switch (resultsType)\r\n            {\r\n               case 0:\r\n                  // Simply set results.\r\n                  results = result;\r\n                  break;\r\n               case 1:\r\n                  // Create a new array from existing results then concat the new result array.\r\n                  results = [results].concat(result);\r\n                  break;\r\n               case 2:\r\n                  // `results` is already an array so concat the new result array.\r\n                  results = results.concat(result);\r\n                  break;\r\n            }\r\n         }\r\n         else if (result !== void 0)\r\n         {\r\n            switch (resultsType)\r\n            {\r\n               case 0:\r\n                  // Simply set results.\r\n                  results = result;\r\n                  break;\r\n               case 1: {\r\n                  // Create a new array from existing results then push the new result value.\r\n                  const newArray = [results];\r\n                  newArray.push(result);\r\n                  results = newArray;\r\n                  break;\r\n               }\r\n               case 2:\r\n                  // `results` is already an array so push the new result array.\r\n                  results.push(result);\r\n                  break;\r\n            }\r\n         }\r\n      }\r\n   }\r\n   else\r\n   {\r\n      // Just single event.\r\n      results = iteratee(iterateeTarget, events, name, callback, opts);\r\n   }\r\n\r\n   return results;\r\n};\r\n\r\n/**\r\n * Handles triggering the appropriate event callbacks.\r\n *\r\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\r\n *\r\n * @param {Events}   objEvents - Array of stored event callback data.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - callback\r\n *\r\n * @param {*[]}      args - Arguments supplied to a trigger method.\r\n *\r\n * @returns {*} The results from the triggered event.\r\n */\r\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\r\n{\r\n   let result;\r\n\r\n   if (objEvents)\r\n   {\r\n      const events = objEvents[name];\r\n      let allEvents = objEvents.all;\r\n      if (events && allEvents) { allEvents = allEvents.slice(); }\r\n      if (events) { result = iterateeTarget(events, args); }\r\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\r\n   }\r\n\r\n   return result;\r\n};\r\n\r\n/**\r\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\r\n * cases speedy (most internal Backbone events have 3 arguments).\r\n *\r\n * @param {EventData[]} events - Array of stored event callback data.\r\n *\r\n * @param {*[]}         args - Event argument array\r\n */\r\nconst s_TRIGGER_EVENTS = (events, args) =>\r\n{\r\n   let ev, i = -1;\r\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\r\n\r\n   switch (args.length)\r\n   {\r\n      case 0:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\r\n         return;\r\n      case 1:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\r\n         return;\r\n      case 2:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\r\n         return;\r\n      case 3:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\r\n         return;\r\n      default:\r\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\r\n         return;\r\n   }\r\n};\r\n\r\n/**\r\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\r\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\r\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\r\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\r\n * use for any asynchronous operations.\r\n *\r\n * @param {EventData[]} events - Array of stored event callback data.\r\n *\r\n * @param {*[]}         args - Arguments supplied to `triggerAsync`.\r\n *\r\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\r\n */\r\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\r\n{\r\n   let ev, i = -1;\r\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\r\n\r\n   const results = [];\r\n\r\n   switch (args.length)\r\n   {\r\n      case 0:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      case 1:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      case 2:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      case 3:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      default:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n   }\r\n\r\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\r\n   return results.length > 1 ? Promise.all(results).then((values) =>\r\n   {\r\n      const filtered = values.filter((entry) => entry !== void 0);\r\n      switch (filtered.length)\r\n      {\r\n         case 0: return void 0;\r\n         case 1: return filtered[0];\r\n         default: return filtered;\r\n      }\r\n   }) : results.length === 1 ? results[0] : void 0;\r\n};\r\n\r\n/**\r\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\r\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\r\n * single value or an array with all results returned by any invoked targets.\r\n *\r\n * @param {EventData[]} events - Array of stored event callback data.\r\n *\r\n * @param {*[]}         args - Arguments supplied to `triggerSync`.\r\n *\r\n * @returns {void|*|*[]} The results from the triggered event.\r\n */\r\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\r\n{\r\n   let ev, i = -1;\r\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\r\n\r\n   const results = [];\r\n\r\n   switch (args.length)\r\n   {\r\n      case 0:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      case 1:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      case 2:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      case 3:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      default:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n   }\r\n\r\n   // Return the results array if there are more than one or just a single result.\r\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\r\n};\r\n\r\n/**\r\n * A try-catch guarded function. Used when attempting to invoke `isGuarded` from an other eventbus / context via\r\n * `listenTo`.\r\n *\r\n * @param {object}         obj - Event target / context\r\n *\r\n * @param {string|object}  name - Event name(s) or event map.\r\n *\r\n * @param {object}         data - Output data.\r\n *\r\n * @returns {boolean} Any error if thrown.\r\n */\r\nconst s_TRY_CATCH_IS_GUARDED = (obj, name, data = {}) =>\r\n{\r\n   let guarded = false;\r\n\r\n   try\r\n   {\r\n      const result = obj.isGuarded(name, data);\r\n      if (typeof result === 'boolean') { guarded = result; }\r\n   }\r\n   catch (err)\r\n   {\r\n      guarded = false;\r\n      data.names = [];\r\n      data.guarded = false;\r\n   }\r\n\r\n   return guarded;\r\n};\r\n\r\n/**\r\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\r\n * invoke `on` from an other eventbus / context via `listenTo`.\r\n *\r\n * @param {object}            obj - Event target / context\r\n *\r\n * @param {string|object}     name - Event name(s) or event map.\r\n *\r\n * @param {Function|object}   callback - Event callback function or context for event map.\r\n *\r\n * @param {object}            [context] - Event context\r\n *\r\n * @returns {Error} Any error if thrown.\r\n */\r\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\r\n{\r\n   try\r\n   {\r\n      obj.on(name, callback, context);\r\n   }\r\n   catch (err)\r\n   {\r\n      return err;\r\n   }\r\n};\r\n\r\n/**\r\n * Generate a unique integer ID (unique within the entire client session).\r\n *\r\n * @type {number} - unique ID counter.\r\n */\r\nlet idCounter = 0;\r\n\r\n/**\r\n * Creates a new unique ID with a given prefix\r\n *\r\n * @param {string}   prefix - An optional prefix to add to unique ID.\r\n *\r\n * @returns {string} A new unique ID with a given prefix.\r\n */\r\nconst s_UNIQUE_ID = (prefix = '') =>\r\n{\r\n   const id = `${++idCounter}`;\r\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\r\n};\r\n","import * as Utils     from './utils.js';\r\n\r\n/**\r\n * EventbusProxy provides a protected proxy of another Eventbus instance.\r\n *\r\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\r\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\r\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\r\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\r\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\r\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\r\n *\r\n * EventbusProxy provides the on / off, before, once, and trigger methods with the same signatures as found in\r\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\r\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition\r\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\r\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\r\n *\r\n * Finally the EventbusProxy only allows events registered through it to be turned off providing a buffer between\r\n * any consumers such that they can not turn off other registrations made on the eventbus or other proxy instances.\r\n */\r\nexport default class EventbusProxy\r\n{\r\n   /**\r\n    * Stores the target eventbus.\r\n    *\r\n    * @type {Eventbus}\r\n    * @private\r\n    */\r\n   #eventbus;\r\n\r\n   /**\r\n    * Stores all proxied event bindings.\r\n    *\r\n    * @type {Events|{}}\r\n    * @private\r\n    */\r\n   #events;\r\n\r\n   /**\r\n    * Creates the event proxy with an existing instance of Eventbus.\r\n    *\r\n    * @param {Eventbus}   eventbus - The target eventbus instance.\r\n    */\r\n   constructor(eventbus)\r\n   {\r\n      this.#eventbus = eventbus;\r\n\r\n      Object.seal(this);\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\r\n    * removed. When multiple events are passed in using the space separated syntax, the event\r\n    * will fire count times for every event you passed in, not once for a combination of all events.\r\n    *\r\n    * @param {number}            count - Number of times the function will fire before being removed.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @param {ProxyOnOptions}    [options] - Event registration options.\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy instance.\r\n    */\r\n   before(count, name, callback, context = void 0, options = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\r\n\r\n      const data = {};\r\n      if (this.#eventbus.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\r\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\r\n    * after `destroy` has been called result in a ReferenceError thrown.\r\n    */\r\n   destroy()\r\n   {\r\n      if (this.#eventbus !== null)\r\n      {\r\n         this.off();\r\n      }\r\n\r\n      this.#events = void 0;\r\n\r\n      this.#eventbus = null;\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for all events from the proxied eventbus yielding an array with event name, callback function,\r\n    * and event context.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *entries(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.entries(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied eventbus event count.\r\n    *\r\n    * @returns {number} Returns the current proxied event count.\r\n    */\r\n   get eventCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.eventCount;\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied eventbus callback count.\r\n    *\r\n    * @returns {number} Returns the current proxied callback count.\r\n    */\r\n   get callbackCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.callbackCount;\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of proxied eventbus event listeners.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keys(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keys(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keysWithOptions(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keysWithOptions(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns whether this EventbusProxy has already been destroyed.\r\n    *\r\n    * @returns {boolean} Is destroyed state.\r\n    */\r\n   get isDestroyed()\r\n   {\r\n      return this.#eventbus === null;\r\n   }\r\n\r\n   /**\r\n    * Returns the target eventbus name.\r\n    *\r\n    * @returns {string} The target eventbus name.\r\n    */\r\n   get name()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return `proxy-${this.#eventbus.name}`;\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied event count.\r\n    *\r\n    * @returns {number} Returns the current proxied event count.\r\n    */\r\n   get proxyEventCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      if (!this.#events) { return 0; }\r\n\r\n      return Object.keys(this.#events).length;\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied callback count.\r\n    *\r\n    * @returns {number} Returns the current proxied callback count.\r\n    */\r\n   get proxyCallbackCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      if (!this.#events) { return 0; }\r\n\r\n      let count = 0;\r\n\r\n      for (const name in this.#events) { count += this.#events[name].length; }\r\n\r\n      return count;\r\n   }\r\n\r\n   /**\r\n    * Returns the options of an event name.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {DataOutOptions} The event options.\r\n    */\r\n   getOptions(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getOptions(name);\r\n   }\r\n\r\n   /**\r\n    * Returns the trigger type of an event name.\r\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {string|undefined} The trigger type.\r\n    */\r\n   getType(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getType(name);\r\n   }\r\n\r\n   /**\r\n    * Returns whether an event name is guarded.\r\n    *\r\n    * @param {string|object}  name - Event name(s) or event map to verify.\r\n    *\r\n    * @param {object}         [data] - Stores the output of which names are guarded.\r\n    *\r\n    * @returns {boolean} Whether the given event name is guarded.\r\n    */\r\n   isGuarded(name, data = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.isGuarded(name, data);\r\n   }\r\n\r\n   /**\r\n    * Remove a previously-bound proxied event binding.\r\n    *\r\n    * Please see {@link Eventbus#off}.\r\n    *\r\n    * @param {string|object}  [name] - Event name(s) or event map.\r\n    *\r\n    * @param {Function}       [callback] - Event callback function\r\n    *\r\n    * @param {object}         [context] - Event context\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy\r\n    */\r\n   off(name = void 0, callback = void 0, context = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events || {}, name, callback, {\r\n         context: context,\r\n         eventbus: this.#eventbus\r\n      });\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\r\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\r\n    * \"change:selection\".\r\n    *\r\n    * Please see {@link Eventbus#on}.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context.\r\n    *\r\n    * @param {ProxyOnOptions}    [options] - Event registration options.\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy\r\n    */\r\n   on(name, callback, context = void 0, options = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\r\n      {\r\n         throw new TypeError(`'options' must be an object literal.`);\r\n      }\r\n\r\n      const data = {};\r\n      if (this.#eventbus.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\r\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Hang onto the options as s_ON_API sets the context we need to pass to the eventbus in `opts.ctx`.\r\n      const opts = { context, ctx: this, options };\r\n\r\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, opts);\r\n\r\n      this.#eventbus.on(name, callback, opts.ctx, options);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\r\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\r\n    * will fire once for every event you passed in, not once for a combination of all events\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            context - Event context\r\n    *\r\n    * @param {ProxyOnOptions}    [options] - Event registration options.\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy instance.\r\n    */\r\n   once(name, callback, context = void 0, options = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      const data = {};\r\n      if (this.#eventbus.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\r\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for all stored locally proxied events yielding an array with event name, callback\r\n    * function, and event context.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *proxyEntries(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               for (const event of this.#events[name])\r\n               {\r\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n               }\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            for (const event of this.#events[name])\r\n            {\r\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of the locally proxied event names.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *proxyKeys(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield name;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield name;\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of the locally proxied event names with event options.\r\n    *\r\n    * Note: The event options returned will respect all of the event options from a registered event event on the main\r\n    * eventbus if applicable.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *proxyKeysWithOptions(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield [name, this.#eventbus.getOptions(name)];\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield [name, this.#eventbus.getOptions(name)];\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\r\n    * passed along to the event callbacks.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy.\r\n    */\r\n   trigger(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      this.#eventbus.trigger(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\r\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\r\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Promise<void|*|*[]>} A Promise returning any results.\r\n    */\r\n   triggerAsync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerAsync(name, ...args);\r\n   }\r\n\r\n   /**\r\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy.\r\n    */\r\n   triggerDefer(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      this.#eventbus.triggerDefer(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\r\n    * value or in an array and passes it back to the callee in a synchronous manner.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {void|*|*[]} An Array of returned results.\r\n    */\r\n   triggerSync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerSync(name, ...args);\r\n   }\r\n}\r\n\r\n/**\r\n * The reducing API that removes a callback from the `events` object. And delegates invoking off to the eventbus\r\n * reference.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {void|Events} Events object\r\n */\r\nconst s_OFF_API = (events, name, callback, opts) =>\r\n{\r\n   /* c8 ignore next 1 */\r\n   if (!events) { return; }\r\n\r\n   const context = opts.context;\r\n   const eventbus = opts.eventbus;\r\n\r\n   const names = name ? [name] : Utils.objectKeys(events);\r\n\r\n   for (let i = 0; i < names.length; i++)\r\n   {\r\n      name = names[i];\r\n      const handlers = events[name];\r\n\r\n      // Bail out if there are no events stored.\r\n      if (!handlers) { break; }\r\n\r\n      // Find any remaining events.\r\n      const remaining = [];\r\n      for (let j = 0; j < handlers.length; j++)\r\n      {\r\n         const handler = handlers[j];\r\n\r\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\r\n          context && context !== handler.context)\r\n         {\r\n            remaining.push(handler);\r\n         }\r\n      }\r\n\r\n      // Replace events if there are any remaining.  Otherwise, clean up.\r\n      if (remaining.length)\r\n      {\r\n         events[name] = remaining;\r\n      }\r\n      else\r\n      {\r\n         eventbus.off(name, callback, context);\r\n         delete events[name];\r\n      }\r\n   }\r\n\r\n   return events;\r\n};\r\n\r\n/**\r\n * The reducing API that adds a callback to the `events` object.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {Events} Events object.\r\n */\r\nconst s_ON_API = (events, name, callback, opts) =>\r\n{\r\n   if (callback)\r\n   {\r\n      const handlers = events[name] || (events[name] = []);\r\n      const context = opts.context, ctx = opts.ctx;\r\n\r\n      // Make a copy of options.\r\n      const options = JSON.parse(JSON.stringify(opts.options));\r\n\r\n      // Ensure that guard is set.\r\n      options.guard = options.guard !== void 0 && typeof options.guard === 'boolean' ? options.guard : false;\r\n\r\n      // Ensure that type is set.\r\n      switch(options.type)\r\n      {\r\n         case 'sync':\r\n            options.type = 1;\r\n            break;\r\n         case 'async':\r\n            options.type = 2;\r\n            break;\r\n         default:\r\n            options.type = 0;\r\n            break;\r\n      }\r\n\r\n      // Set opts `ctx` as this is what we send to the eventbus.\r\n      opts.ctx = context || ctx;\r\n\r\n      handlers.push({ callback, context, ctx: opts.ctx, options });\r\n   }\r\n\r\n   return events;\r\n};\r\n","/**\r\n * EventbusSecure provides a secure wrapper around another Eventbus instance.\r\n *\r\n * The main use case of EventbusSecure is to provide a secure eventbus window for general public consumption. Only\r\n * events can be triggered, but not registered / unregistered.\r\n *\r\n * You must use the initialize method passing in an existing Eventbus instance as the eventbus reference is private.\r\n * In order to secure the eventbus from unwanted access there is no way to access the eventbus reference externally from\r\n * the EventbusSecure instance. The initialize method returns an {@link EventbusSecureObj} object which\r\n * contains two functions to control the secure eventbus externally; `destroy` and `setEventbus`. Expose to end\r\n * consumers just the `eventbusSecure` instance.\r\n */\r\nexport default class EventbusSecure\r\n{\r\n   /**\r\n    * Stores the target eventbus.\r\n    *\r\n    * @type {Eventbus}\r\n    * @private\r\n    */\r\n   #eventbus;\r\n\r\n   /**\r\n    * Stores a potentially alternate name instead of returning the wrapped Eventbus instance name.\r\n    *\r\n    * @type {string}\r\n    * @private\r\n    */\r\n   #name\r\n\r\n   /**\r\n    * Creates the EventbusSecure instance with an existing instance of Eventbus. An object / EventbusSecureObj is\r\n    * returned with an EventbusSecure reference and two functions for controlling the underlying Eventbus reference.\r\n    *\r\n    * `destroy()` will destroy the underlying Eventbus reference.\r\n    * `setEventbus(<eventbus>)` will set the underlying reference.\r\n    *\r\n    * @param {Eventbus|EventbusProxy}  eventbus - The target eventbus instance.\r\n    *\r\n    * @param {string}                  [name] - If a name is provided this will be used instead of eventbus name.\r\n    *\r\n    * @returns {EventbusSecureObj} The control object which contains an EventbusSecure reference and control functions.\r\n    */\r\n   static initialize(eventbus, name = void 0)\r\n   {\r\n      if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string.`); }\r\n\r\n      const eventbusSecure = new EventbusSecure();\r\n      eventbusSecure.#eventbus = eventbus;\r\n      eventbusSecure.#name = name === void 0 ? eventbus.name : name;\r\n      Object.seal(eventbusSecure);\r\n\r\n      return {\r\n         destroy: function()\r\n         {\r\n            if (!eventbusSecure.isDestroyed)\r\n            {\r\n               eventbusSecure.#eventbus = null;\r\n\r\n               if (this) { this.eventbusSecure = void 0 }\r\n            }\r\n         },\r\n\r\n         setEventbus: function(eventbus, name = void 0)\r\n         {\r\n            if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string.`); }\r\n\r\n            if (!eventbusSecure.isDestroyed)\r\n            {\r\n               // Adopt the new eventbus name as the current name set matches the wrapped eventbus.\r\n               if (name === void 0 && eventbusSecure.#name === eventbusSecure.#eventbus.name)\r\n               {\r\n                  eventbusSecure.#name = eventbus.name;\r\n               }\r\n               else if (name !== void 0)\r\n               {\r\n                  eventbusSecure.#name = name;\r\n               }\r\n\r\n               eventbusSecure.#eventbus = eventbus;\r\n            }\r\n         },\r\n\r\n         eventbusSecure\r\n      };\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of secured eventbus event listeners.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keys(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keys(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keysWithOptions(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keysWithOptions(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns whether this instance has already been destroyed.\r\n    *\r\n    * @returns {boolean} Is destroyed state.\r\n    */\r\n   get isDestroyed()\r\n   {\r\n      return this.#eventbus === null;\r\n   }\r\n\r\n   /**\r\n    * Returns the name associated with this instance.\r\n    *\r\n    * @returns {string} The target eventbus name.\r\n    */\r\n   get name()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#name;\r\n   }\r\n\r\n   /**\r\n    * Returns the options of an event name.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {DataOutOptions} The event options.\r\n    */\r\n   getOptions(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getOptions(name);\r\n   }\r\n\r\n   /**\r\n    * Returns the trigger type of an event name.\r\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {string|undefined} The trigger type.\r\n    */\r\n   getType(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getType(name);\r\n   }\r\n\r\n   /**\r\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\r\n    * passed along to the event callbacks.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusSecure} This instance.\r\n    */\r\n   trigger(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      this.#eventbus.trigger(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\r\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\r\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Promise<void|*|*[]>} A Promise to returning any results.\r\n    */\r\n   triggerAsync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerAsync(name, ...args);\r\n   }\r\n\r\n   /**\r\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusSecure} This EventbusProxy.\r\n    */\r\n   triggerDefer(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      this.#eventbus.triggerDefer(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\r\n    * value or in an array and passes it back to the callee in a synchronous manner.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {void|*|*[]} An Array of returned results.\r\n    */\r\n   triggerSync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerSync(name, ...args);\r\n   }\r\n}\r\n","import Eventbus                        from './Eventbus.js';\r\n\r\nexport { default as EventbusProxy }    from './EventbusProxy.js';\r\nexport { default as EventbusSecure }   from './EventbusSecure.js';\r\n\r\nexport default Eventbus;\r\n\r\n/**\r\n * Provides a main eventbus instance.\r\n *\r\n * @type {Eventbus}\r\n */\r\nexport const eventbus = new Eventbus('mainEventbus');\r\n\r\n/**\r\n * Provides an eventbus instance potentially for use with a plugin system.\r\n *\r\n * @type {Eventbus}\r\n */\r\nexport const pluginEventbus = new Eventbus('pluginEventbus');\r\n\r\n/**\r\n * Provides an eventbus instance potentially for use for testing.\r\n *\r\n * @type {Eventbus}\r\n */\r\nexport const testEventbus = new Eventbus('testEventbus');\r\n"],"names":["eventSplitter","eventsAPI","iteratee","events","name","callback","opts","names","i","context","objectKeys","length","test","split","getErrorName","eventbus","getOptions","output","handlers","Array","isArray","handler","options","guard","type","object","Object","keys","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","this","arguments","_callback","before","result","args","Eventbus","constructor","TypeError","_listeners","_listenId","_listeningTo","Number","isInteger","data","isGuarded","console","warn","Utils","JSON","stringify","off","bind","on","regex","RegExp","event","_classPrivateFieldGet","parse","getType","s_GET_TYPE","guarded","s_IS_GUARDED","listenTo","obj","s_TRY_CATCH_IS_GUARDED","id","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","listenToBefore","stopListening","listenToOnce","s_OFF_API","listeners","s_ON_API","ctx","once","ids","trigger","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","Promise","all","then","results","allResults","pResult","concat","push","triggerDefer","setTimeout","triggerSync","s_TRIGGER_SYNC_EVENTS","listener","cleanup","incrementCount","value","remaining","j","iterateeTarget","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","async","values","filtered","filter","entry","err","idCounter","prefix","EventbusProxy","seal","isDestroyed","ReferenceError","destroy","entries","eventCount","callbackCount","keysWithOptions","triggerAsync","EventbusSecure","eventbusSecure","setEventbus","pluginEventbus","testEventbus"],"mappings":"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"}